/**
 * Configuration Loader - Load and validate config from YAML + env
 */

import fs from 'node:fs';
import path from 'node:path';
import yaml from 'js-yaml';
import dotenv from 'dotenv';
import { ConfigSchema, type Config } from './schema.js';

// Load .env file
dotenv.config();

let cachedConfig: Config | null = null;

/**
 * Interpolate environment variables in config values
 */
function interpolateEnv(obj: unknown): unknown {
  if (typeof obj === 'string') {
    return obj.replace(/\$\{(\w+)\}/g, (_, key) => process.env[key] || '');
  }
  if (Array.isArray(obj)) {
    return obj.map(interpolateEnv);
  }
  if (obj !== null && typeof obj === 'object') {
    const result: Record<string, unknown> = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = interpolateEnv(value);
    }
    return result;
  }
  return obj;
}

/**
 * Load configuration from file and environment
 */
export function loadConfig(configPath?: string): Config {
  if (cachedConfig && !configPath) {
    return cachedConfig;
  }

  const searchPaths = configPath
    ? [configPath]
    : [
        path.join(process.cwd(), 'pm.config.yaml'),
        path.join(process.cwd(), 'pm.config.yml'),
      ];

  let rawConfig: Record<string, unknown> = {};

  for (const p of searchPaths) {
    if (fs.existsSync(p)) {
      const content = fs.readFileSync(p, 'utf-8');
      rawConfig = yaml.load(content) as Record<string, unknown>;
      break;
    }
  }

  // Interpolate environment variables
  const interpolated = interpolateEnv(rawConfig);

  // Apply environment variable overrides
  const envOverrides: Record<string, unknown> = {};

  if (process.env.LLM_PROVIDER) {
    envOverrides.provider = { default: process.env.LLM_PROVIDER };
  }
  if (process.env.DATABASE_PATH) {
    envOverrides.database = { path: process.env.DATABASE_PATH };
  }
  if (process.env.LOG_LEVEL) {
    envOverrides.logging = { level: process.env.LOG_LEVEL };
  }

  // Merge config with overrides
  const merged = deepMerge(interpolated as Record<string, unknown>, envOverrides);

  // Validate with Zod
  const result = ConfigSchema.safeParse(merged);
  if (!result.success) {
    const errors = result.error.errors.map(e => `${e.path.join('.')}: ${e.message}`);
    throw new Error(`Configuration validation failed:\n${errors.join('\n')}`);
  }

  cachedConfig = result.data;
  return cachedConfig;
}

/**
 * Get the current configuration
 */
export function getConfig(): Config {
  return loadConfig();
}

/**
 * Clear cached configuration
 */
export function clearConfigCache(): void {
  cachedConfig = null;
}

/**
 * Generate default configuration YAML
 */
export function generateDefaultConfig(): string {
  return `# Polymarket Prediction CLI Configuration
# Generated by dominion-pm init

general:
  name: "Polymarket Analysis"
  environment: "development"

provider:
  default: "stub"
  openai:
    model: "gpt-4-turbo-preview"
    temperature: 0.2
    max_tokens: 2048
  anthropic:
    model: "claude-3-5-sonnet-20241022"
    temperature: 0.2
    max_tokens: 2048

polymarket:
  base_url: "https://clob.polymarket.com"
  gamma_url: "https://gamma-api.polymarket.com"
  poll_interval_sec: 60
  timeout_ms: 30000

scoring:
  min_liquidity: 1000
  min_volume: 100
  max_spread: 0.10
  default_top_n: 20

simulation:
  fee_bps: 100
  slippage_bps: 50
  confidence_band: 0.10
  default_position_size: 10

reporting:
  out_dir: "./reports"
  include_raw_data: false

rate_limits:
  polymarket_rps: 5
  llm_rpm: 20
  max_retries: 3
  base_delay_ms: 1000
  max_delay_ms: 30000

database:
  path: "./data/polymarket.db"
  wal_mode: true

logging:
  level: "info"
  format: "json"
`;
}

/**
 * Deep merge two objects
 */
function deepMerge(target: Record<string, unknown>, source: Record<string, unknown>): Record<string, unknown> {
  const result = { ...target };
  for (const key of Object.keys(source)) {
    if (source[key] !== null && typeof source[key] === 'object' && !Array.isArray(source[key])) {
      result[key] = deepMerge(
        (result[key] as Record<string, unknown>) || {},
        source[key] as Record<string, unknown>
      );
    } else {
      result[key] = source[key];
    }
  }
  return result;
}

